#pragma once

#include <cstddef>
#include <cstdint>
#include <memory>
#include <vector>

#include <boost/asio/ip/tcp.hpp>
#include <boost/beast/core.hpp>

namespace wss
{
    class peer_write : public std::enable_shared_from_this<peer_write>
    {
        public:

            peer_write(boost::asio::ip::tcp::socket& socket);

            void set_backlog(std::size_t bytes);

            template <typename ConstBufferSequence>
            boost::system::error_code write(const ConstBufferSequence& buffers)
            {
                // If we already have user-space buffered data and are waiting for the socket to
                // become writeable, we just need to add the additional data to the user-space
                // buffer; the wait completion handler will see the additional data along with
                // whatever was previously buffered.
                if (waiting)
                    return enqueue(buffers);

                // Otherwise, send as much as we can synchronously.
                boost::system::error_code send_ec;
                std::size_t bytes_sent = socket.send(buffers, 0, send_ec);

                // Did a genuine error occur?
                if (send_ec && send_ec != boost::asio::error::would_block)
                    return send_ec;

                // Did we synchronously send all the requested data?
                if (bytes_sent == boost::asio::buffer_size(buffers))
                    return boost::system::error_code{};

                // There is leftover data that could not be sent synchronously. Buffer up the
                // remaining data and start an asynchronous wait for the socket to become
                // writeable.
                boost::beast::buffers_suffix suffix{buffers};
                suffix.consume(bytes_sent);
                return enqueue(suffix);
            }

        private:

            template <typename ConstBufferSequence>
            boost::system::error_code enqueue(const ConstBufferSequence& buffers)
            {
                std::size_t bytes_buffered = boost::asio::buffer_copy(
                    boost::asio::mutable_buffer(
                        buffer.data() + bytes_in_buffer,
                        buffer.size() - bytes_in_buffer),
                    buffers);

                bytes_in_buffer += bytes_buffered;

                if (bytes_in_buffer == buffer.size())
                    return boost::asio::error::no_buffer_space;

                if (!waiting)
                    do_wait();

                return boost::system::error_code{};
            }

            void do_wait_tx()
            {
                socket.async_wait(
                    boost::asio::socket_base::wait_write,
                    std::bind(
                        &peer_write::on_wait_complete,
                        shared_from_this(),
                        std::placeholders::_1));

                tx_waiting = true;
            }

            void on_wait_complete(const boost::system::error_code& wait_ec)
            {
                boost::system::error_code send_ec;
                waiting = false;

                // Was there an error waiting for the socket to become writeable?
                if (wait_ec)
                    return on_async_error(wait_ec);

                // Since the socket is writeable, write as much as we can to it.
                std::size_t bytes_sent = socket.send(
                    boost::asio::buffer(buffer.data(), bytes_in_buffer),
                    0,
                    send_ec);

                // Was there a genuine error writing to the socket?
                if (send_ec && send_ec != boost::asio::error::would_block)
                    return on_async_error(send_ec);

                // If we sent all the data in our buffer, we can stop now.
                if (bytes_sent)
                    std::memmove(
                        buffer.data(),
                        &buffer[bytes_sent],
                        bytes_in_buffer - bytes_sent);
                bytes_in_buffer -= bytes_sent;

                if (bytes_sent < bytes_in_buffer)
                    do_wait();
            }

            void on_async_error(const boost::system::error_code& ec)
            {
            }

            boost::asio::ip::tcp::socket& socket;


            std::vector<std::uint8_t> buffer;
            std::size_t bytes_in_buffer = 0;

            bool waiting = false;
    };
}
